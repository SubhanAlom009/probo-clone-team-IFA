import { db } from "./firebase";
import {
  collection,
  addDoc,
  getDocs,
  doc,
  getDoc,
  updateDoc,
  setDoc,
  increment,
  serverTimestamp,
  runTransaction,
  query,
  where,
  orderBy,
} from "firebase/firestore";

// Ensure user profile exists (call right after signup / sign-in)
export async function ensureUserProfile(user) {
  const ref = doc(db, "users", user.uid);
  const snap = await getDoc(ref);
  if (!snap.exists()) {
    await setDoc(
      ref,
      {
        displayName: user.displayName || user.email?.split("@")[0] || "User",
        photoURL: user.photoURL || null,
        balance: 1000,
        role: "admin", // All users are admins by default
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
      },
      { merge: true }
    );
  }
}

// Safer explicit create (call once after signup)
export async function createUserProfile(user) {
  const ref = doc(db, "users", user.uid);
  const snap = await getDoc(ref);
  if (snap.exists()) return;
  await updateDoc(ref, {}).catch(async () => {
    // If update fails (no doc) fallback to set via transaction
    await runTransaction(db, async (tx) => {
      tx.set(ref, {
        displayName: user.displayName || user.email?.split("@")[0] || "User",
        photoURL: user.photoURL || null,
        balance: 1000, // initial virtual coins
        role: "admin", // All users are admins by default
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
      });
    });
  });
}

export async function getUserProfile(uid) {
  const ref = doc(db, "users", uid);
  const snap = await getDoc(ref);
  return snap.exists() ? { id: snap.id, ...snap.data() } : null;
}

// Create event (admin)
export async function createEvent(title, description, closesAt, createdBy) {
  const docRef = await addDoc(collection(db, "events"), {
    title,
    description,
    status: "open",
    yesStake: 0,
    noStake: 0,
    totalStake: 0,
    createdAt: serverTimestamp(),
    closesAt,
    createdBy,
    resolvedOutcome: null,
    resolvedAt: null,
  });
  return docRef.id;
}

// Bulk dummy events (admin / dev utility)
export async function seedDummyEvents(createdBy, count = 5) {
  const samples = [
    "Will Bitcoin close above $70k this week?",
    "Will SpaceX launch a Starship orbital test this month?",
    "Will XYZ stock gain 5% by Friday?",
    "Will there be rainfall in Mumbai tomorrow?",
    "Will a major AI regulation bill pass this quarter?",
  ];
  const ids = [];
  for (let i = 0; i < count; i++) {
    const title = samples[i % samples.length];
    const closesAt = new Date(
      Date.now() + (36 + i * 6) * 60 * 60 * 1000
    ).toISOString();
    const id = await createEvent(
      title,
      "Autogenerated market for testing.",
      closesAt,
      createdBy
    );
    ids.push(id);
  }
  return ids;
}

// Get all events (basic list)
export async function getEvents() {
  const snapshot = await getDocs(collection(db, "events"));
  return snapshot.docs.map((d) => ({ id: d.id, ...d.data() }));
}

// Place an order in the order book and match against opposite orders
export async function placeOrder({ eventId, userId, side, price, quantity }) {
  if (quantity <= 0) throw new Error("Quantity must be > 0");
  if (!["yes", "no"].includes(side)) throw new Error("Invalid side");
  if (price < 1 || price > 10)
    throw new Error("Price must be between 1 and 10");

  const eventRef = doc(db, "events", eventId);
  const userRef = doc(db, "users", userId);
  const ordersCol = collection(db, "orders");
  const betsCol = collection(db, "bets");

  await runTransaction(db, async (tx) => {
    const [eventSnap, userSnap] = await Promise.all([
      tx.get(eventRef),
      tx.get(userRef),
    ]);
    if (!eventSnap.exists()) throw new Error("Event not found");
    if (!userSnap.exists()) throw new Error("User not found");

    const event = eventSnap.data();
    const user = userSnap.data();

    if (event.status !== "open") throw new Error("Event not open");
    if (event.closesAt && Date.now() > new Date(event.closesAt).getTime())
      throw new Error("Event closed");

    // Calculate locked amount for this order
    const lockedAmount =
      side === "yes" ? quantity * price : quantity * (10 - price);
    if (user.balance < lockedAmount) throw new Error("Insufficient balance");

    // Query open opposite orders at this price, sorted by createdAt (FIFO)
    const oppSide = side === "yes" ? "no" : "yes";
    const oppOrdersQ = query(
      ordersCol,
      where("eventId", "==", eventId),
      where("side", "==", oppSide),
      where("price", "==", price),
      where("status", "==", "open"),
      orderBy("createdAt", "asc")
    );
    const oppOrdersSnap = await getDocs(oppOrdersQ);
    const oppOrders = oppOrdersSnap.docs.map((d) => ({
      id: d.id,
      ...d.data(),
    }));

    let remainingQty = quantity;
    let userLocked = 0;
    for (const opp of oppOrders) {
      if (remainingQty <= 0) break;
      const fillQty = Math.min(remainingQty, opp.quantityRemaining);
      // Lock funds for both sides
      const yesUserId = side === "yes" ? userId : opp.userId;
      const noUserId = side === "no" ? userId : opp.userId;
      const yesLocked = fillQty * price;
      const noLocked = fillQty * (10 - price);

      // Update counterparty order
      const oppOrderRef = doc(db, "orders", opp.id);
      tx.update(oppOrderRef, {
        quantityRemaining: opp.quantityRemaining - fillQty,
        status: opp.quantityRemaining - fillQty === 0 ? "filled" : "open",
        // Recalculate lockedAmount for the remaining (unmatched) portion of the resting order
        lockedAmount:
          (opp.quantityRemaining - fillQty) *
          (opp.side === "yes" ? opp.price : 10 - opp.price),
      });

      // Create bet for matched shares
      const betRef = doc(betsCol);
      tx.set(betRef, {
        eventId,
        price,
        quantity: fillQty,
        yesUserId,
        noUserId,
        yesLocked,
        noLocked,
        status: "pending",
        winner: null,
        createdAt: serverTimestamp(),
      });

      // Lock funds for this user (only for matched qty)
      userLocked += fillQty * (side === "yes" ? price : 10 - price);

      // Lock funds for counterparty (already locked in their order)

      remainingQty -= fillQty;
    }

    // Deduct locked funds for matched and unmatched qty
    const unmatchedQty = remainingQty;
    const unmatchedLocked =
      unmatchedQty * (side === "yes" ? price : 10 - price);
    const totalLocked = userLocked + unmatchedLocked;
    if (user.balance < totalLocked) throw new Error("Insufficient balance");

    // If any unmatched, rest as open order
    if (unmatchedQty > 0) {
      const orderRef = doc(ordersCol);
      tx.set(orderRef, {
        eventId,
        userId,
        side,
        price,
        quantity: unmatchedQty,
        quantityRemaining: unmatchedQty,
        lockedAmount: unmatchedLocked,
        status: "open",
        createdAt: serverTimestamp(),
      });
    }

    // Deduct total locked funds from user
    tx.update(userRef, {
      balance: user.balance - totalLocked,
      updatedAt: serverTimestamp(),
    });
  });
}

// Cancel an open (or partially filled but still open) order and refund remaining locked funds
export async function cancelOrder({ orderId, userId }) {
  const orderRef = doc(db, "orders", orderId);
  const userRef = userId ? doc(db, "users", userId) : null;
  await runTransaction(db, async (tx) => {
    const orderSnap = await tx.get(orderRef);
    if (!orderSnap.exists()) throw new Error("Order not found");
    const order = orderSnap.data();
    if (order.userId !== userId) throw new Error("Not your order");
    if (order.status !== "open") throw new Error("Order not open");
    if (!userRef) throw new Error("User ref missing");
    const userSnap = await tx.get(userRef);
    if (!userSnap.exists()) throw new Error("User not found");
    const user = userSnap.data();
    const refund = order.lockedAmount || 0;

    tx.update(orderRef, {
      status: "cancelled",
      cancelledAt: serverTimestamp(),
      refundedAmount: refund,
      lockedAmount: 0,
    });

    if (refund > 0) {
      tx.update(userRef, {
        balance: (user.balance || 0) + refund,
        updatedAt: serverTimestamp(),
      });
      const ledgerRef = doc(collection(db, "users", userId, "ledger"));
      tx.set(ledgerRef, {
        type: "cancel-refund",
        orderId,
        amount: refund,
        createdAt: serverTimestamp(),
      });
    }
  });
}

// Resolve event (admin) for order book model
export async function resolveEvent(eventId, outcome, resolverId) {
  if (!["yes", "no"].includes(outcome)) throw new Error("Bad outcome");
  const eventRef = doc(db, "events", eventId);
  // Mark event as resolved
  await runTransaction(db, async (tx) => {
    const eventSnap = await tx.get(eventRef);
    if (!eventSnap.exists()) throw new Error("Event not found");
    const eventData = eventSnap.data();
    if (eventData.status === "resolved") throw new Error("Already resolved");
    tx.update(eventRef, {
      status: "resolved",
      resolvedOutcome: outcome,
      resolvedAt: serverTimestamp(),
      resolvedBy: resolverId,
    });
  });

  // Settle bets (matched orders)
  const betsQ = query(collection(db, "bets"), where("eventId", "==", eventId));
  const betSnaps = await getDocs(betsQ);
  const bets = betSnaps.docs.map((d) => ({ id: d.id, ...d.data() }));
  for (const bet of bets) {
    if (bet.status === "settled") continue;
    const winnerId = outcome === "yes" ? bet.yesUserId : bet.noUserId;
    const totalPayout = (bet.yesLocked || 0) + (bet.noLocked || 0);
    const betRef = doc(db, "bets", bet.id);
    const winnerRef = doc(db, "users", winnerId);
    await runTransaction(db, async (tx) => {
      tx.update(betRef, {
        status: "settled",
        winner: outcome,
        settledAt: serverTimestamp(),
      });
      tx.update(winnerRef, {
        balance: increment(totalPayout),
        updatedAt: serverTimestamp(),
      });
      const ledgerRef = doc(collection(db, "users", winnerId, "ledger"));
      tx.set(ledgerRef, {
        type: "payout",
        eventId,
        betId: bet.id,
        amount: totalPayout,
        createdAt: serverTimestamp(),
      });
    });
  }

  // Refund unmatched open orders
  const ordersQ = query(
    collection(db, "orders"),
    where("eventId", "==", eventId),
    where("status", "==", "open")
  );
  const orderSnaps = await getDocs(ordersQ);
  for (const order of orderSnaps.docs.map((d) => ({ id: d.id, ...d.data() }))) {
    if (!order.lockedAmount || order.lockedAmount <= 0) continue;
    const userRef = doc(db, "users", order.userId);
    const orderRef = doc(db, "orders", order.id);
    await runTransaction(db, async (tx) => {
      tx.update(orderRef, {
        status: "refunded",
        refundedAt: serverTimestamp(),
      });
      tx.update(userRef, {
        balance: increment(order.lockedAmount),
        updatedAt: serverTimestamp(),
      });
      const ledgerRef = doc(collection(db, "users", order.userId, "ledger"));
      tx.set(ledgerRef, {
        type: "refund",
        eventId,
        orderId: order.id,
        amount: order.lockedAmount,
        createdAt: serverTimestamp(),
      });
    });
  }
}

// Query bets for a user on an event
export async function getUserBetsForEvent(userId, eventId) {
  const q = query(
    collection(db, "bets"),
    where("userId", "==", userId),
    where("eventId", "==", eventId),
    orderBy("createdAt", "desc")
  );
  const snap = await getDocs(q);
  return snap.docs.map((d) => ({ id: d.id, ...d.data() }));
}

// Simple aggregate metrics for a user
export async function getUserMetrics(userId) {
  const betsQ = query(collection(db, "bets"), where("userId", "==", userId));
  const snap = await getDocs(betsQ);
  let totalStake = 0;
  let resolved = 0;
  let wins = 0;
  let returns = 0;
  snap.docs.forEach((d) => {
    const b = d.data();
    totalStake += b.stake || 0;
    if (b.settled) {
      resolved += 1;
      if (b.outcome && b.outcome === b.side) {
        wins += 1;
      }
      if (b.payout) returns += b.payout;
    }
  });
  const winRate = resolved ? wins / resolved : 0;
  return {
    totalStake,
    resolvedBets: resolved,
    wins,
    winRate,
    totalReturn: returns,
    profit: returns - totalStake,
  };
}

// Role upgrade request store minimal doc on user
export async function requestRoleUpgrade(userId) {
  const ref = doc(db, "users", userId);
  await updateDoc(ref, {
    upgradeRequested: true,
    upgradeRequestedAt: serverTimestamp(),
  });
}

export async function approveRoleUpgrade(userId) {
  const ref = doc(db, "users", userId);
  await updateDoc(ref, {
    role: "admin",
    upgradeRequested: false,
    upgradedAt: serverTimestamp(),
  });
}
