import { db } from "./firebase";
import {
  collection,
  addDoc,
  getDocs,
  doc,
  getDoc,
  updateDoc,
  setDoc,
  increment,
  serverTimestamp,
  runTransaction,
  query,
  where,
  orderBy,
} from "firebase/firestore";

// Ensure user profile exists (call right after signup / sign-in)
export async function ensureUserProfile(user) {
  const ref = doc(db, "users", user.uid);
  const snap = await getDoc(ref);
  if (!snap.exists()) {
    await setDoc(
      ref,
      {
        displayName: user.displayName || user.email?.split("@")[0] || "User",
        photoURL: user.photoURL || null,
        balance: 1000,
        role: "admin", // All users are admins by default
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
      },
      { merge: true }
    );
  }
}

// Safer explicit create (call once after signup)
export async function createUserProfile(user) {
  const ref = doc(db, "users", user.uid);
  const snap = await getDoc(ref);
  if (snap.exists()) return;
  await updateDoc(ref, {}).catch(async () => {
    // If update fails (no doc) fallback to set via transaction
    await runTransaction(db, async (tx) => {
      tx.set(ref, {
        displayName: user.displayName || user.email?.split("@")[0] || "User",
        photoURL: user.photoURL || null,
        balance: 1000, // initial virtual coins
        role: "admin", // All users are admins by default
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
      });
    });
  });
}

export async function getUserProfile(uid) {
  const ref = doc(db, "users", uid);
  const snap = await getDoc(ref);
  return snap.exists() ? { id: snap.id, ...snap.data() } : null;
}

// Create event (admin)
export async function createEvent(title, description, closesAt, createdBy) {
  const docRef = await addDoc(collection(db, "events"), {
    title,
    description,
    status: "open",
    yesStake: 0,
    noStake: 0,
    totalStake: 0,
    createdAt: serverTimestamp(),
    closesAt,
    createdBy,
    resolvedOutcome: null,
    resolvedAt: null,
  });
  return docRef.id;
}

// Bulk dummy events (admin / dev utility)
export async function seedDummyEvents(createdBy, count = 5) {
  const samples = [
    "Will Bitcoin close above $70k this week?",
    "Will SpaceX launch a Starship orbital test this month?",
    "Will XYZ stock gain 5% by Friday?",
    "Will there be rainfall in Mumbai tomorrow?",
    "Will a major AI regulation bill pass this quarter?",
  ];
  const ids = [];
  for (let i = 0; i < count; i++) {
    const title = samples[i % samples.length];
    const closesAt = new Date(
      Date.now() + (36 + i * 6) * 60 * 60 * 1000
    ).toISOString();
    const id = await createEvent(
      title,
      "Autogenerated market for testing.",
      closesAt,
      createdBy
    );
    ids.push(id);
  }
  return ids;
}

// Get all events (basic list)
export async function getEvents() {
  const snapshot = await getDocs(collection(db, "events"));
  return snapshot.docs.map((d) => ({ id: d.id, ...d.data() }));
}

// Place an order in the order book and match against opposite orders
export async function placeOrder({ eventId, userId, side, price, quantity }) {
  if (quantity <= 0) throw new Error("Quantity must be > 0");
  if (!["yes", "no"].includes(side)) throw new Error("Invalid side");
  if (price < 0.5 || price > 9.5)
    throw new Error("Price must be between 0.5 and 9.5");

  const eventRef = doc(db, "events", eventId);
  const userRef = doc(db, "users", userId);
  const ordersCol = collection(db, "orders");
  const betsCol = collection(db, "bets");

  await runTransaction(db, async (tx) => {
    const [eventSnap, userSnap] = await Promise.all([
      tx.get(eventRef),
      tx.get(userRef),
    ]);
    if (!eventSnap.exists()) throw new Error("Event not found");
    if (!userSnap.exists()) throw new Error("User not found");

    const event = eventSnap.data();
    const user = userSnap.data();

    if (event.status !== "open") throw new Error("Event not open");
    if (event.closesAt && Date.now() > new Date(event.closesAt).getTime())
      throw new Error("Event closed");

    // Calculate locked amount for this order
    const lockedAmount =
      side === "yes" ? quantity * price : quantity * (10 - price);
    if (user.balance < lockedAmount) throw new Error("Insufficient balance");

    // Probo-style: YES at ₹P matches NO at ₹(10−P) only
    const oppSide = side === "yes" ? "no" : "yes";
    const matchPrice = 10 - price;
    const oppOrdersQ = query(
      ordersCol,
      where("eventId", "==", eventId),
      where("side", "==", oppSide),
      where("price", "==", matchPrice),
      where("status", "==", "open"),
      orderBy("createdAt", "asc")
    );
    const oppOrdersSnap = await getDocs(oppOrdersQ);
    const oppOrders = oppOrdersSnap.docs.map((d) => ({
      id: d.id,
      ...d.data(),
    }));

    let remainingQty = quantity;
    let userLocked = 0;
    for (const opp of oppOrders) {
      if (remainingQty <= 0) break;
      const fillQty = Math.min(remainingQty, opp.quantityRemaining);
      // Always use the YES order's price for both sides' locked funds
      const yesOrderPrice = side === "yes" ? price : opp.price;
      const yesUserId = side === "yes" ? userId : opp.userId;
      const noUserId = side === "no" ? userId : opp.userId;
      const yesLocked = fillQty * yesOrderPrice;
      const noLocked = fillQty * (10 - yesOrderPrice);

      // Update counterparty order
      const oppOrderRef = doc(db, "orders", opp.id);
      const newQtyRem = opp.quantityRemaining - fillQty;
      tx.update(oppOrderRef, {
        quantityRemaining: newQtyRem,
        status: newQtyRem === 0 ? "filled" : "open",
        lockedAmount:
          newQtyRem * (opp.side === "yes" ? opp.price : 10 - opp.price),
      });

      // Create bet for matched shares
      const betRef = doc(betsCol);
      tx.set(betRef, {
        eventId,
        price: yesOrderPrice, // always store the YES price for clarity
        quantity: fillQty,
        yesUserId,
        noUserId,
        yesLocked,
        noLocked,
        status: "pending",
        winner: null,
        createdAt: serverTimestamp(),
      });

      // Lock funds for this user (only for matched qty)
      if (side === "yes") {
        userLocked += fillQty * price;
      } else {
        // For NO taker, use the matched YES price (opp.price)
        userLocked += fillQty * (10 - opp.price);
      }

      // Lock funds for counterparty (already locked in their order)

      remainingQty -= fillQty;
    }

    // Deduct locked funds for matched and unmatched qty
    const unmatchedQty = remainingQty;
    const unmatchedLocked =
      unmatchedQty * (side === "yes" ? price : 10 - price);
    const totalLocked = userLocked + unmatchedLocked;
    if (user.balance < totalLocked) throw new Error("Insufficient balance");

    // If any unmatched, rest as open order
    if (unmatchedQty > 0) {
      const orderRef = doc(ordersCol);
      tx.set(orderRef, {
        eventId,
        userId,
        side,
        price,
        quantity: unmatchedQty,
        quantityRemaining: unmatchedQty,
        lockedAmount: unmatchedLocked,
        status: "open",
        createdAt: serverTimestamp(),
      });
    }
    // Always create a filled order for the taker for matched qty (even if partial)
    if (quantity - unmatchedQty > 0) {
      const orderRef = doc(ordersCol);
      tx.set(orderRef, {
        eventId,
        userId,
        side,
        price,
        quantity: quantity - unmatchedQty,
        quantityRemaining: 0,
        lockedAmount: 0,
        status: "filled",
        createdAt: serverTimestamp(),
        filledAt: serverTimestamp(),
      });
    }

    // Deduct total locked funds from user
    tx.update(userRef, {
      balance: user.balance - totalLocked,
      updatedAt: serverTimestamp(),
    });
  });
}

// Cancel an open (or partially filled but still open) order and refund remaining locked funds
export async function cancelOrder({ orderId, userId }) {
  const orderRef = doc(db, "orders", orderId);
  const userRef = userId ? doc(db, "users", userId) : null;
  await runTransaction(db, async (tx) => {
    const orderSnap = await tx.get(orderRef);
    if (!orderSnap.exists()) throw new Error("Order not found");
    const order = orderSnap.data();
    if (order.userId !== userId) throw new Error("Not your order");
    if (order.status !== "open") throw new Error("Order not open");
    if (!userRef) throw new Error("User ref missing");
    const userSnap = await tx.get(userRef);
    if (!userSnap.exists()) throw new Error("User not found");
    const user = userSnap.data();
    const refund = order.lockedAmount || 0;

    tx.update(orderRef, {
      status: "cancelled",
      cancelledAt: serverTimestamp(),
      refundedAmount: refund,
      lockedAmount: 0,
    });

    if (refund > 0) {
      tx.update(userRef, {
        balance: (user.balance || 0) + refund,
        updatedAt: serverTimestamp(),
      });
      const ledgerRef = doc(collection(db, "users", userId, "ledger"));
      tx.set(ledgerRef, {
        type: "cancel-refund",
        orderId,
        amount: refund,
        createdAt: serverTimestamp(),
      });
    }
  });
}

// Resolve event (admin) for order book model
export async function resolveEvent(eventId, outcome, resolverId) {
  if (!["yes", "no"].includes(outcome)) throw new Error("Bad outcome");
  const eventRef = doc(db, "events", eventId);
  // Mark event as resolved
  await runTransaction(db, async (tx) => {
    const eventSnap = await tx.get(eventRef);
    if (!eventSnap.exists()) throw new Error("Event not found");
    const eventData = eventSnap.data();
    if (eventData.status === "resolved") throw new Error("Already resolved");
    tx.update(eventRef, {
      status: "resolved",
      resolvedOutcome: outcome,
      resolvedAt: serverTimestamp(),
      resolvedBy: resolverId,
    });
  });

  // Settle bets (matched orders)
  const betsQ = query(collection(db, "bets"), where("eventId", "==", eventId));
  const betSnaps = await getDocs(betsQ);
  const bets = betSnaps.docs.map((d) => ({ id: d.id, ...d.data() }));
  for (const bet of bets) {
    if (bet.status === "settled") continue;
    const winnerId = outcome === "yes" ? bet.yesUserId : bet.noUserId;
    const loserId = outcome === "yes" ? bet.noUserId : bet.yesUserId;
    const totalPayout = (bet.yesLocked || 0) + (bet.noLocked || 0);

    // Check if self-matching (same user on both sides)
    const isSelfMatch = bet.yesUserId === bet.noUserId;

    let commission = 0;
    let finalPayout = totalPayout;

    if (isSelfMatch) {
      // For self-matching: user should lose commission amount only
      const winnerStake =
        outcome === "yes" ? bet.yesLocked || 0 : bet.noLocked || 0;
      const loserStake =
        outcome === "yes" ? bet.noLocked || 0 : bet.yesLocked || 0;
      const profit = loserStake; // Profit = what the losing side locked
      commission = profit * 0.2; // 20% commission on profit
      finalPayout = totalPayout - commission; // User gets back locked amount minus commission
    } else {
      // Normal bet: Apply 20% commission on winnings (not on returned stake)
      const winnerStake =
        outcome === "yes" ? bet.yesLocked || 0 : bet.noLocked || 0;
      const winnings = totalPayout - winnerStake; // Profit part
      commission = winnings * 0.2; // 20% commission on profit
      finalPayout = totalPayout - commission; // Total minus commission
    }

    const betRef = doc(db, "bets", bet.id);
    const winnerRef = doc(db, "users", winnerId);
    const loserRef = doc(db, "users", loserId);
    await runTransaction(db, async (tx) => {
      tx.update(betRef, {
        status: "settled",
        winner: outcome,
        commission: commission,
        finalPayout: finalPayout,
        settledAt: serverTimestamp(),
        isSelfMatch: isSelfMatch,
      });

      if (isSelfMatch) {
        // Self-match: User should only get back the net loss (commission)
        // Their balance was already reduced by totalPayout when placing orders
        const netResult = finalPayout - totalPayout; // This will be negative (commission loss)
        tx.update(winnerRef, {
          balance: increment(netResult), // Add negative amount (subtract commission)
          updatedAt: serverTimestamp(),
        });
        const ledgerRef = doc(collection(db, "users", winnerId, "ledger"));
        tx.set(ledgerRef, {
          type: "self-match-settlement",
          eventId,
          betId: bet.id,
          amount: netResult, // Show the actual loss
          commission: commission,
          grossPayout: totalPayout,
          lockedAmount: totalPayout,
          netResult: netResult, // Should be negative (commission loss)
          createdAt: serverTimestamp(),
        });
      } else {
        // Normal bet: Update winner and loser separately
        tx.update(winnerRef, {
          balance: increment(finalPayout),
          updatedAt: serverTimestamp(),
        });
        const ledgerRef = doc(collection(db, "users", winnerId, "ledger"));
        tx.set(ledgerRef, {
          type: "payout",
          eventId,
          betId: bet.id,
          amount: finalPayout,
          commission: commission,
          grossPayout: totalPayout,
          createdAt: serverTimestamp(),
        });
        // Add a loss entry for the losing party
        const lossLedgerRef = doc(collection(db, "users", loserId, "ledger"));
        tx.set(lossLedgerRef, {
          type: "loss",
          eventId,
          betId: bet.id,
          amount: -(loserId === bet.noUserId
            ? bet.noLocked || 0
            : bet.yesLocked || 0),
          createdAt: serverTimestamp(),
        });
      }
    });
  }

  // Refund all unmatched open orders (including partially matched ones with remaining quantity)
  const ordersQ = query(
    collection(db, "orders"),
    where("eventId", "==", eventId),
    where("status", "==", "open")
  );
  const orderSnaps = await getDocs(ordersQ);
  for (const order of orderSnaps.docs.map((d) => ({ id: d.id, ...d.data() }))) {
    // Only refund if there's remaining locked amount
    if (!order.lockedAmount || order.lockedAmount <= 0) continue;

    // For unmatched or partially matched orders, refund the remaining locked amount
    const userRef = doc(db, "users", order.userId);
    const orderRef = doc(db, "orders", order.id);
    await runTransaction(db, async (tx) => {
      tx.update(orderRef, {
        status: "refunded",
        refundedAt: serverTimestamp(),
        refundedAmount: order.lockedAmount,
      });
      tx.update(userRef, {
        balance: increment(order.lockedAmount),
        updatedAt: serverTimestamp(),
      });
      const ledgerRef = doc(collection(db, "users", order.userId, "ledger"));
      tx.set(ledgerRef, {
        type: "refund",
        eventId,
        orderId: order.id,
        amount: order.lockedAmount,
        createdAt: serverTimestamp(),
      });
    });
  }
}

// Query bets for a user on an event
export async function getUserBetsForEvent(userId, eventId) {
  const qYes = query(
    collection(db, "bets"),
    where("yesUserId", "==", userId),
    where("eventId", "==", eventId),
    orderBy("createdAt", "desc")
  );
  const qNo = query(
    collection(db, "bets"),
    where("noUserId", "==", userId),
    where("eventId", "==", eventId),
    orderBy("createdAt", "desc")
  );
  const [snapYes, snapNo] = await Promise.all([getDocs(qYes), getDocs(qNo)]);
  const allBets = [...snapYes.docs, ...snapNo.docs].map((d) => ({
    id: d.id,
    ...d.data(),
  }));

  // Deduplicate and sort
  const uniqueBets = allBets.filter(
    (bet, index, self) => index === self.findIndex((b) => b.id === bet.id)
  );
  uniqueBets.sort(
    (a, b) => (b.createdAt?.seconds || 0) - (a.createdAt?.seconds || 0)
  );

  return uniqueBets;
}

// Simple aggregate metrics for a user
export async function getUserMetrics(userId) {
  const betsQ = query(collection(db, "bets"), where("yesUserId", "==", userId));
  const betsQ2 = query(collection(db, "bets"), where("noUserId", "==", userId));
  const [snap1, snap2] = await Promise.all([getDocs(betsQ), getDocs(betsQ2)]);
  const allBets = [...snap1.docs, ...snap2.docs].map((d) => ({
    id: d.id,
    ...d.data(),
  }));
  let totalStake = 0;
  let resolved = 0;
  let wins = 0;
  let returns = 0;
  for (const b of allBets) {
    // User's locked amount for this bet
    let userLocked = 0;
    if (b.yesUserId === userId) userLocked = b.yesLocked || 0;
    if (b.noUserId === userId) userLocked = b.noLocked || 0;
    totalStake += userLocked;
    if (b.status === "settled") {
      resolved += 1;
      // User wins if they are the winner
      if (
        (b.winner === "yes" && b.yesUserId === userId) ||
        (b.winner === "no" && b.noUserId === userId)
      ) {
        wins += 1;
        returns += (b.yesLocked || 0) + (b.noLocked || 0);
      }
    }
  }
  const winRate = resolved ? wins / resolved : 0;
  return {
    totalStake,
    resolvedBets: resolved,
    wins,
    winRate,
    totalReturn: returns,
    profit: returns - totalStake,
  };
}

// Role upgrade request store minimal doc on user
export async function requestRoleUpgrade(userId) {
  const ref = doc(db, "users", userId);
  await updateDoc(ref, {
    upgradeRequested: true,
    upgradeRequestedAt: serverTimestamp(),
  });
}

export async function approveRoleUpgrade(userId) {
  const ref = doc(db, "users", userId);
  await updateDoc(ref, {
    role: "admin",
    upgradeRequested: false,
    upgradedAt: serverTimestamp(),
  });
}
