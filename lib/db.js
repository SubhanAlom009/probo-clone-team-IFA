import { db } from "./firebase";
import {
  collection,
  addDoc,
  getDocs,
  doc,
  getDoc,
  updateDoc,
  setDoc,
  increment,
  serverTimestamp,
  runTransaction,
  query,
  where,
  orderBy,
} from "firebase/firestore";

// Ensure user profile exists (call right after signup / sign-in)
export async function ensureUserProfile(user) {
  const ref = doc(db, "users", user.uid);
  const snap = await getDoc(ref);
  if (!snap.exists()) {
    await setDoc(
      ref,
      {
        displayName: user.displayName || user.email?.split("@")[0] || "User",
        photoURL: user.photoURL || null,
        balance: 1000,
        role: "admin", // All users are admins by default
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
      },
      { merge: true }
    );
  }
}

// Safer explicit create (call once after signup)
export async function createUserProfile(user) {
  const ref = doc(db, "users", user.uid);
  const snap = await getDoc(ref);
  if (snap.exists()) return;
  await updateDoc(ref, {}).catch(async () => {
    // If update fails (no doc) fallback to set via transaction
    await runTransaction(db, async (tx) => {
      tx.set(ref, {
        displayName: user.displayName || user.email?.split("@")[0] || "User",
        photoURL: user.photoURL || null,
        balance: 1000, // initial virtual coins
        role: "admin", // All users are admins by default
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
      });
    });
  });
}

export async function getUserProfile(uid) {
  const ref = doc(db, "users", uid);
  const snap = await getDoc(ref);
  return snap.exists() ? { id: snap.id, ...snap.data() } : null;
}

// Create event (admin)
export async function createEvent(title, description, closesAt, createdBy) {
  const docRef = await addDoc(collection(db, "events"), {
    title,
    description,
    status: "open",
    yesStake: 0,
    noStake: 0,
    totalStake: 0,
    createdAt: serverTimestamp(),
    closesAt,
    createdBy,
    resolvedOutcome: null,
    resolvedAt: null,
  });
  return docRef.id;
}

// Bulk dummy events (admin / dev utility)
export async function seedDummyEvents(createdBy, count = 5) {
  const samples = [
    "Will Bitcoin close above $70k this week?",
    "Will SpaceX launch a Starship orbital test this month?",
    "Will XYZ stock gain 5% by Friday?",
    "Will there be rainfall in Mumbai tomorrow?",
    "Will a major AI regulation bill pass this quarter?",
  ];
  const ids = [];
  for (let i = 0; i < count; i++) {
    const title = samples[i % samples.length];
    const closesAt = new Date(
      Date.now() + (36 + i * 6) * 60 * 60 * 1000
    ).toISOString();
    const id = await createEvent(
      title,
      "Autogenerated market for testing.",
      closesAt,
      createdBy
    );
    ids.push(id);
  }
  return ids;
}

// Get all events (basic list)
export async function getEvents() {
  const snapshot = await getDocs(collection(db, "events"));
  return snapshot.docs.map((d) => ({ id: d.id, ...d.data() }));
}

// Place bet transactionally
export async function placeBet({ eventId, userId, side, stake }) {
  if (stake <= 0) throw new Error("Stake must be > 0");
  if (!["yes", "no"].includes(side)) throw new Error("Invalid side");

  const eventRef = doc(db, "events", eventId);
  const userRef = doc(db, "users", userId);
  const betsCol = collection(db, "bets");

  await runTransaction(db, async (tx) => {
    const [eventSnap, userSnap] = await Promise.all([
      tx.get(eventRef),
      tx.get(userRef),
    ]);
    if (!eventSnap.exists()) throw new Error("Event not found");
    if (!userSnap.exists()) throw new Error("User not found");

    const event = eventSnap.data();
    const user = userSnap.data();

    if (event.status !== "open") throw new Error("Event not open");
    if (event.closesAt && Date.now() > new Date(event.closesAt).getTime())
      throw new Error("Event closed");
    if (user.balance < stake) throw new Error("Insufficient balance");

    const yesStake = event.yesStake || 0;
    const noStake = event.noStake || 0;
    const impliedYes =
      yesStake + noStake > 0 ? yesStake / (yesStake + noStake) : 0.5;

    const betRef = doc(betsCol); // auto id
    tx.set(betRef, {
      eventId,
      userId,
      side,
      stake,
      createdAt: serverTimestamp(),
      oddsSnapshot: impliedYes, // store market snapshot (yes probability)
      settled: false,
    });

    tx.update(eventRef, {
      [side === "yes" ? "yesStake" : "noStake"]: increment(stake),
      totalStake: increment(stake),
      updatedAt: serverTimestamp(),
    });

    tx.update(userRef, {
      balance: user.balance - stake,
      updatedAt: serverTimestamp(),
    });
  });
}

// Resolve event (admin)
export async function resolveEvent(eventId, outcome, resolverId) {
  if (!["yes", "no"].includes(outcome)) throw new Error("Bad outcome");
  const eventRef = doc(db, "events", eventId);
  // We'll resolve & payout in one transaction; if pool huge we could batch but fine for MVP.
  await runTransaction(db, async (tx) => {
    const eventSnap = await tx.get(eventRef);
    if (!eventSnap.exists()) throw new Error("Event not found");
    const eventData = eventSnap.data();
    if (eventData.status === "resolved") throw new Error("Already resolved");

    // Lock the event first
    tx.update(eventRef, {
      status: "resolved",
      resolvedOutcome: outcome,
      resolvedAt: serverTimestamp(),
      resolvedBy: resolverId,
    });

    // Fetch bets for this event (Firestores limitation: can't inside tx with query getDocs? We can, but need to use tx.get for each doc id. Simplicity: prefetch outside? Instead: store minimal flag and do payouts post). For MVP we'll do two-phase: mark resolved then payouts outside transaction.
  });

  // Phase 2: payouts (outside transaction to allow querying). This introduces tiny race if double-called; guard with idempotency by checking bet.settled.
  const betsQ = query(collection(db, "bets"), where("eventId", "==", eventId));
  const betSnaps = await getDocs(betsQ);
  const bets = betSnaps.docs.map((d) => ({ id: d.id, ...d.data() }));
  const winningBets = bets.filter((b) => b.side === outcome && !b.settled);
  if (!bets.length) return; // nothing to do
  const totalStake = bets.reduce((s, b) => s + (b.stake || 0), 0);
  const winningPool = winningBets.reduce((s, b) => s + (b.stake || 0), 0);
  if (winningPool === 0) {
    // Edge: no winners -> optionally refund? We'll leave pool unclaimed.
    return;
  }
  // Payout = totalStake * (stake / winningPool)
  // Track ledger entries.
  for (const wb of winningBets) {
    const userRef = doc(db, "users", wb.userId);
    const betRef = doc(db, "bets", wb.id);
    await runTransaction(db, async (tx) => {
      const betSnap = await tx.get(betRef);
      if (!betSnap.exists()) return; // gone
      const betData = betSnap.data();
      if (betData.settled) return; // idempotent
      const payout = totalStake * (betData.stake / winningPool);
      tx.update(betRef, {
        settled: true,
        payout,
        settledAt: serverTimestamp(),
        outcome: outcome,
      });
      tx.update(userRef, {
        balance: increment(payout),
        updatedAt: serverTimestamp(),
      });
      const ledgerRef = doc(collection(db, "users", wb.userId, "ledger"));
      tx.set(ledgerRef, {
        type: "payout",
        eventId,
        betId: wb.id,
        amount: payout,
        createdAt: serverTimestamp(),
      });
    });
  }
}

// Query bets for a user on an event
export async function getUserBetsForEvent(userId, eventId) {
  const q = query(
    collection(db, "bets"),
    where("userId", "==", userId),
    where("eventId", "==", eventId),
    orderBy("createdAt", "desc")
  );
  const snap = await getDocs(q);
  return snap.docs.map((d) => ({ id: d.id, ...d.data() }));
}

// Simple aggregate metrics for a user
export async function getUserMetrics(userId) {
  const betsQ = query(collection(db, "bets"), where("userId", "==", userId));
  const snap = await getDocs(betsQ);
  let totalStake = 0;
  let resolved = 0;
  let wins = 0;
  let returns = 0;
  snap.docs.forEach((d) => {
    const b = d.data();
    totalStake += b.stake || 0;
    if (b.settled) {
      resolved += 1;
      if (b.outcome && b.outcome === b.side) {
        wins += 1;
      }
      if (b.payout) returns += b.payout;
    }
  });
  const winRate = resolved ? wins / resolved : 0;
  return {
    totalStake,
    resolvedBets: resolved,
    wins,
    winRate,
    totalReturn: returns,
    profit: returns - totalStake,
  };
}

// Role upgrade request store minimal doc on user
export async function requestRoleUpgrade(userId) {
  const ref = doc(db, "users", userId);
  await updateDoc(ref, {
    upgradeRequested: true,
    upgradeRequestedAt: serverTimestamp(),
  });
}

export async function approveRoleUpgrade(userId) {
  const ref = doc(db, "users", userId);
  await updateDoc(ref, {
    role: "admin",
    upgradeRequested: false,
    upgradedAt: serverTimestamp(),
  });
}
